set -U fish_greeting
set -U SXHKD_SHELL sh
set -gx SKIM_DEFAULT_COMMAND "fd --type f"
set -gx BROWSER firefox
set -gx EDITOR hx
set -gx VISUAL hx
set -gx GOPATH $HOME/proj/go
set -gx GOBIN $HOME/.local/bin
set -gx GO111MODULE on
set -gx TD_HOME $HOME/ds/code
set -gx PGHOST /var/run/postgresql
set -gx DS_LOCAL_DATA $HOME/ds/.local/data
set -gx TRAVEL_EXP_DIR $DS_LOCAL_DATA/travel/
set -gx ERL_AFLAGS "+pc unicode -kernel shell_history enabled"
set -gx EMACS $HOME/.local/bin/emacs
set -gx MANPATH (manpath -q)
set -Ux PYENV_ROOT $HOME/.pyenv

fish_add_path --prepend --global /usr/lib/llvm-14/bin \
    $HOME/.emacs.d/bin \
    $HOME/.cargo/bin \
    $HOME/.local/bin \
    $HOME/.cache/rebar3/bin \
    $HOME/.luarocks/bin \
    $HOME/.local/bin/zig \
    $PYENV_ROOT/bin \
    $HOME/.roswell/bin \
    /usr/local/go/bin

set -gx TIMELOG {{ .timelog }}

alias .j='just --justfile ~/.user.justfile --working-directory .'
alias apt='doas /usr/bin/apt'
alias nala='doas {{ if eq .chezmoi.hostname "tpt440pdev" -}} /usr/local/bin/nala {{- else -}} /usr/bin/nala {{- end -}}'
alias c='cargo'
alias cm='chezmoi'
alias e='hx'
alias edit='hx'
alias g='git'
alias gvim='neovide'
alias j='just'
alias ledger='ledger -f $TIMELOG'
alias ll='exa --all --long --icons --classify --group-directories-first --sort name --time-style long-iso'
alias neovim='nvim'
alias urlencode='python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.argv[1]))"'
alias vi='nvim'
alias vim='nvim'
alias yless='jless --yaml'

umask 027
zoxide init fish | source
starship init fish | source
source $HOME/.asdf/asdf.fish
pyenv init - | source
jj util completion --fish | source

gpgconf --launch gpg-agent

if test -z (pgrep ssh-agent | string collect)
    eval (ssh-agent -c)
    set -Ux SSH_AUTH_SOCK $SSH_AUTH_SOCK
    set -Ux SSH_AGENT_PID $SSH_AGENT_PID
end

function add-today-to-travel-exp
    set -l dir $TRAVEL_EXP_DIR(date +%Y/%m)
    mkdir -p $dir
    date -I >>$dir/dates.txt
end

alias ato add-today-to-travel-exp

function clock-in
    date +"i %Y/%m/%d %H:%M:%S e:ds:td:overhead" >> $TIMELOG
end

function clock-out
    date +"o %Y/%m/%d %H:%M:%S" >> $TIMELOG
end

alias ci clock-in
alias co clock-out

function maybe-add-key -a key_name
    ssh-add -l | rg -wq $key_name
    if test $status -ne 0
        ssh-add $HOME/.ssh/id_$key_name
    end
end

function update-repos
    maybe-add-key basbossink-ds
    maybe-add-key basbossink-ds-servers
    pushd $TD_HOME
    fd -uu --max-depth 3 --type d '\.git$' -x sh -c "cd {//}; printf '\n\033[0;32m*****+{//}+*%50s\033[0m\n'| tr ' ' '*' |tr '+' ' '; git fetch --prune --verbose; printf '\n'"
    popd
end

alias urs update-repos

function show-overtime
    set -l today_start (tail -n 20 $TIMELOG | rg (date +%Y/%m/%d) | rg '^i ' | head -1 | cut -d' ' -f2,3 | tr '/:' ' ')
    set -l worked_today (ledger bal --period 'today' | awk '{ print $1 }')
    ledger --daily reg | TODAY_START=$today_start WORKED_TODAY=$worked_today over-time.awk | column --table -s =
end

alias over show-overtime
alias tls tlsum

function jump-to-repo-root
    pushd (git rev-parse --show-toplevel)
    commandline -f repaint
end

alias jrr jump-to-repo-root
bind \eh jump-to-repo-root

function run-ci
    jump-to-repo-root
    TD_LOG_LEVEL=warn c xc
    popd
end

bind \ei run-ci

function git-push-new-branch
    set -l branch_name (git branch --show-current)
    git push -u origin $branch_name
end

alias gpso git-push-new-branch

function search-notes
    pushd $HOME/notes
    $EDITOR (sk --ansi -i -c 'rg -i --color=always --line-number "{}"' | cut -d: -f1,2)
    popd
end

alias sn search-notes

function create-note
    $EDITOR $HOME/notes/(date +"%Y_%m_%dT%H_%M_%S.md")
end

alias note create-note
alias cn create-note

function cmdsave
  set line (echo $history[1])
  the-way cmd $line
end

function cmdsearch
  commandline (the-way search --languages=sh --stdout)
end

function skim_key_bindings

  # Store current token in $dir as root for the 'find' command
  function skim-file-widget -d "List files and folders"
    set -l commandline (__skim_parse_commandline)
    set -l dir $commandline[1]
    set -l skim_query $commandline[2]

    # "-path \$dir'*/\\.*'" matches hidden files/folders inside $dir but not
    # $dir itself, even if hidden.
    test -n "$SKIM_CTRL_T_COMMAND"; or set -l SKIM_CTRL_T_COMMAND "
    command find -L \$dir -mindepth 1 \\( -path \$dir'*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' \\) -prune \
    -o -type f -print \
    -o -type d -print \
    -o -type l -print 2> /dev/null | sed 's@^\./@@'"

    test -n "$SKIM_TMUX_HEIGHT"; or set SKIM_TMUX_HEIGHT 40%
    begin
      set -lx SKIM_DEFAULT_OPTIONS "--height $SKIM_TMUX_HEIGHT --reverse $SKIM_DEFAULT_OPTIONS $SKIM_CTRL_T_OPTS"
      eval "$SKIM_CTRL_T_COMMAND | "(__skimcmd)' -m --query "'$skim_query'"' | while read -l r; set result $result $r; end
    end
    if [ -z "$result" ]
      commandline -f repaint
      return
    else
      # Remove last token from commandline.
      commandline -t ""
    end
    for i in $result
      commandline -it -- (string escape $i)
      commandline -it -- ' '
    end
    commandline -f repaint
  end

  function skim-history-widget -d "Show command history"
    test -n "$SKIM_TMUX_HEIGHT"; or set SKIM_TMUX_HEIGHT 40%
    begin
      set -lx SKIM_DEFAULT_OPTIONS "--height $SKIM_TMUX_HEIGHT $SKIM_DEFAULT_OPTIONS --tiebreak=index --bind=ctrl-r:toggle-sort $SKIM_CTRL_R_OPTS --no-multi"

      set -l FISH_MAJOR (echo $version | cut -f1 -d.)
      set -l FISH_MINOR (echo $version | cut -f2 -d.)

      # history's -z flag is needed for multi-line support.
      # history's -z flag was added in fish 2.4.0, so don't use it for versions
      # before 2.4.0.
      if [ "$FISH_MAJOR" -gt 2 -o \( "$FISH_MAJOR" -eq 2 -a "$FISH_MINOR" -ge 4 \) ];
        history -z | eval (__skimcmd) --read0 --print0 -q '(commandline)' | read -lz result
        and commandline -- $result
      else
        history | eval (__skimcmd) -q '(commandline)' | read -l result
        and commandline -- $result
      end
    end
    commandline -f repaint
  end

  function skim-cd-widget -d "Change directory"
    set -l commandline (__skim_parse_commandline)
    set -l dir $commandline[1]
    set -l skim_query $commandline[2]

    test -n "$SKIM_ALT_C_COMMAND"; or set -l SKIM_ALT_C_COMMAND "
    command find -L \$dir -mindepth 1 \\( -path \$dir'*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' \\) -prune \
    -o -type d -print 2> /dev/null | sed 's@^\./@@'"
    test -n "$SKIM_TMUX_HEIGHT"; or set SKIM_TMUX_HEIGHT 40%
    begin
      set -lx SKIM_DEFAULT_OPTIONS "--height $SKIM_TMUX_HEIGHT --reverse $SKIM_DEFAULT_OPTIONS $SKIM_ALT_C_OPTS"
      eval "$SKIM_ALT_C_COMMAND | "(__skimcmd)' --no-multi --query "'$skim_query'"' | read -l result

      if [ -n "$result" ]
        cd $result

        # Remove last token from commandline.
        commandline -t ""
      end
    end

    commandline -f repaint
  end

  function __skimcmd
    test -n "$SKIM_TMUX"; or set SKIM_TMUX 0
    test -n "$SKIM_TMUX_HEIGHT"; or set SKIM_TMUX_HEIGHT 40%
    if [ -n "$SKIM_TMUX_OPTS" ]
      echo "sk-tmux $SKIM_TMUX_OPTS -- "
    else if [ $SKIM_TMUX -eq 1 ]
      echo "sk-tmux -d$SKIM_TMUX_HEIGHT -- "
    else
      echo "sk"
    end
  end

  bind \ct skim-file-widget
  bind \cr skim-history-widget
  bind \cs skim-cd-widget

  if bind -M insert > /dev/null 2>&1
    bind -M insert \ct skim-file-widget
    bind -M insert \cr skim-history-widget
    bind -M insert \cs skim-cd-widget
  end

  function __skim_parse_commandline -d 'Parse the current command line token and return split of existing filepath and rest of token'
    # eval is used to do shell expansion on paths
    set -l commandline (eval "printf '%s' "(commandline -t))

    if [ -z $commandline ]
      # Default to current directory with no --query
      set dir '.'
      set skim_query ''
    else
      set dir (__skim_get_dir $commandline)

      if [ "$dir" = "." -a (string sub -l 1 -- $commandline) != '.' ]
        # if $dir is "." but commandline is not a relative path, this means no file path found
        set skim_query $commandline
      else
        # Also remove trailing slash after dir, to "split" input properly
        set skim_query (string replace -r "^$dir/?" -- '' "$commandline")
      end
    end

    echo $dir
    echo $skim_query
  end

  function __skim_get_dir -d 'Find the longest existing filepath from input string'
    set dir $argv

    # Strip all trailing slashes. Ignore if $dir is root dir (/)
    if [ (string length -- $dir) -gt 1 ]
      set dir (string replace -r '/*$' -- '' $dir)
    end

    # Iteratively check if dir exists and strip tail end of path
    while [ ! -d "$dir" ]
      # If path is absolute, this can keep going until ends up at /
      # If path is relative, this can keep going until entire input is consumed, dirname returns "."
      set dir (dirname -- "$dir")
    end

    echo $dir
  end

end
skim_key_bindings

if test -e ~/.local/bin/erl/25.0.3/activate.fish
	. ~/.local/bin/erl/25.0.3/activate.fish
end

{{- if eq .chezmoi.hostname "tpt440pdev" }}
direnv hook fish | source
{{- end }}

function vterm_printf;
    if begin; [  -n "$TMUX" ]  ; and  string match -q -r "screen|tmux" "$TERM"; end
        # tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$argv"
    else if string match -q -- "screen*" "$TERM"
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$argv"
    else
        printf "\e]%s\e\\" "$argv"
    end
end

if [ "$INSIDE_EMACS" = 'vterm' ]
    function clear
        vterm_printf "51;Evterm-clear-scrollback";
        tput clear;
    end
end


function vterm_prompt_end;
    vterm_printf '51;A'(whoami)'@'(hostname)':'(pwd)
end

functions --copy fish_prompt vterm_old_fish_prompt

function fish_prompt --description 'Write out the prompt; do not replace this. Instead, put this at end of your file.'
    # Remove the trailing newline from the original prompt. This is done
    # using the string builtin from fish, but to make sure any escape codes
    # are correctly interpreted, use %b for printf.
    printf "%b" (string join "\n" (vterm_old_fish_prompt))
    vterm_prompt_end
end

function vterm_cmd --description 'Run an Emacs command among the ones been defined in vterm-eval-cmds.'
    set -l vterm_elisp ()
    for arg in $argv
        set -a vterm_elisp (printf '"%s" ' (string replace -a -r '([\\\\"])' '\\\\\\\\$1' $arg))
    end
    vterm_printf '51;E'(string join '' $vterm_elisp)
end

function find_file;
    set -q argv[1]; or set argv[1] "."
    vterm_cmd find-file (realpath "$argv")
end
